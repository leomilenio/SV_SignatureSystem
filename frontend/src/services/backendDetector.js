/**
 * Backend Auto-Detection Service
 * Detecta autom√°ticamente en qu√© puerto est√° corriendo el backend FastAPI
 * Soporta detecci√≥n tanto en localhost como en la IP de red local
 */

class BackendDetector {
  constructor() {
    this.detectedPort = null
    this.detectedBaseUrl = null
    this.portRange = { start: 8000, end: 8010 }
    this.testEndpoint = '/health' // Endpoint simple para verificar conectividad
    this.currentHost = this.getCurrentHost()
  }

  /**
   * Obtiene el host actual basado en la URL del navegador
   * @returns {string}
   */
  getCurrentHost() {
    // Si estamos accediendo por IP, usar esa IP para el backend
    // Si estamos en localhost, usar localhost
    const hostname = window.location.hostname
    
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return '127.0.0.1'
    }
    
    // Si accedemos por IP de red local, usar esa misma IP para el backend
    return hostname
  }

  /**
   * Obtiene una lista de hosts candidatos para probar
   * @returns {string[]}
   */
  getCandidateHosts() {
    const currentHost = window.location.hostname
    const hosts = []
    
    // Siempre probar la IP fija del servidor backend primero
    hosts.push('10.0.1.76') // IP del servidor donde siempre estar√° el backend
    
    // Luego probar el host actual
    if (currentHost === 'localhost' || currentHost === '127.0.0.1') {
      hosts.push('127.0.0.1', 'localhost')
    } else {
      hosts.push(currentHost)
    }
    
    // Si estamos accediendo desde una IP de red, tambi√©n probar localhost
    // por si el backend est√° corriendo en la misma m√°quina
    if (currentHost !== 'localhost' && currentHost !== '127.0.0.1') {
      // Intentar obtener las IPs comunes de la misma red
      const ipParts = currentHost.split('.')
      if (ipParts.length === 4) {
        // Probar algunas IPs comunes de la misma red (servidor t√≠pico)
        const baseNetwork = `${ipParts[0]}.${ipParts[1]}.${ipParts[2]}`
        hosts.push(`${baseNetwork}.1`) // Gateway com√∫n
        hosts.push(`${baseNetwork}.100`) // IP com√∫n para servidores
        hosts.push(`${baseNetwork}.10`) // IP com√∫n para servidores
      }
    }
    
    return [...new Set(hosts)] // Eliminar duplicados
  }

  /**
   * Detecta autom√°ticamente el puerto del backend
   * @returns {Promise<{port: number, baseUrl: string}>}
   */
  async detectBackend() {
    console.log('üîç Iniciando detecci√≥n autom√°tica del backend...')
    
    // Si ya detectamos un puerto previamente, intentar usarlo primero
    if (this.detectedPort && this.detectedBaseUrl) {
      console.log(`‚ö° Probando configuraci√≥n previa: ${this.detectedBaseUrl}`)
      const host = new URL(this.detectedBaseUrl).hostname
      if (await this.testSpecificHostPort(host, this.detectedPort)) {
        console.log(`‚úÖ Backend confirmado en ${this.detectedBaseUrl}`)
        return {
          port: this.detectedPort,
          baseUrl: this.detectedBaseUrl
        }
      } else {
        console.log(`‚ùå Configuraci√≥n previa no responde, buscando nuevamente...`)
        this.detectedPort = null
        this.detectedBaseUrl = null
      }
    }

    // Obtener lista de hosts candidatos
    const candidateHosts = this.getCandidateHosts()
    console.log(`üéØ Hosts candidatos: ${candidateHosts.join(', ')}`)

    // Buscar en el rango de puertos para cada host
    for (const host of candidateHosts) {
      console.log(`üîç Probando host: ${host}`)
      
      for (let port = this.portRange.start; port <= this.portRange.end; port++) {
        console.log(`üîç Probando puerto ${port} en ${host}...`)
        
        if (await this.testSpecificHostPort(host, port)) {
          this.detectedPort = port
          this.detectedBaseUrl = `http://${host}:${port}`
          this.currentHost = host
          
          console.log(`‚úÖ ¬°Backend encontrado en ${this.detectedBaseUrl}!`)
          
          // Guardar en localStorage para pr√≥ximas sesiones
          localStorage.setItem('signance_backend_port', port.toString())
          localStorage.setItem('signance_backend_url', this.detectedBaseUrl)
          localStorage.setItem('signance_backend_host', host)
          
          return {
            port: this.detectedPort,
            baseUrl: this.detectedBaseUrl
          }
        }
      }
    }

    throw new Error(`‚ùå No se pudo encontrar el backend en ning√∫n host candidato (${candidateHosts.join(', ')}) en puertos ${this.portRange.start}-${this.portRange.end}`)
  }

  /**
   * Prueba si un puerto espec√≠fico tiene el backend corriendo
   * @param {number} port 
   * @returns {Promise<boolean>}
   */
  async testPort(port) {
    return await this.testSpecificHostPort(this.currentHost, port)
  }

  /**
   * Prueba un host y puerto espec√≠ficos
   * @param {string} host 
   * @param {number} port 
   * @returns {Promise<boolean>}
   */
  async testSpecificHostPort(host, port) {
    const baseUrl = `http://${host}:${port}`
    
    try {
      // Crear un AbortController para el timeout
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 3000) // 3 segundos
      
      // Intentar conectar al endpoint de health
      const response = await fetch(`${baseUrl}${this.testEndpoint}`, {
        method: 'GET',
        signal: controller.signal,
        mode: 'cors', // Importante para CORS
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      })

      clearTimeout(timeoutId)

      if (response.ok) {
        const data = await response.json()
        // Verificar que sea realmente nuestro backend FastAPI
        if (data.status === 'healthy' || data.module === 'auth' || response.status === 200) {
          console.log(`‚úÖ Puerto ${port} en ${host}: Backend FastAPI confirmado - ${JSON.stringify(data)}`)
          return true
        }
      }
    } catch (error) {
      // Puerto no disponible o error de conexi√≥n
      if (error.name === 'AbortError') {
        console.log(`‚è±Ô∏è Puerto ${port} en ${host}: Timeout (3s)`)
      } else {
        console.log(`‚ùå Puerto ${port} en ${host}: ${error.message}`)
      }
    }

    return false
  }

  /**
   * Obtiene la configuraci√≥n del backend desde localStorage
   * @returns {{port: number, baseUrl: string} | null}
   */
  getCachedBackend() {
    const port = localStorage.getItem('signance_backend_port')
    const baseUrl = localStorage.getItem('signance_backend_url')
    const cachedHost = localStorage.getItem('signance_backend_host')
    
    // Verificar si el host cambi√≥ (acceso desde diferente IP)
    if (cachedHost && cachedHost !== this.currentHost) {
      console.log(`üîÑ Host cambi√≥ de ${cachedHost} a ${this.currentHost}, limpiando cach√©...`)
      this.clearCache()
      return null
    }
    
    if (port && baseUrl) {
      return {
        port: parseInt(port),
        baseUrl: baseUrl
      }
    }
    
    return null
  }

  /**
   * Limpia la cach√© de detecci√≥n
   */
  clearCache() {
    localStorage.removeItem('signance_backend_port')
    localStorage.removeItem('signance_backend_url')
    localStorage.removeItem('signance_backend_host')
    this.detectedPort = null
    this.detectedBaseUrl = null
  }

  /**
   * Verifica peri√≥dicamente que el backend siga disponible
   * @param {Function} onConnectionLost - Callback cuando se pierde la conexi√≥n
   */
  startHealthCheck(onConnectionLost) {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval)
    }

    this.healthCheckInterval = setInterval(async () => {
      if (this.detectedPort) {
        const isOnline = await this.testPort(this.detectedPort)
        if (!isOnline && onConnectionLost) {
          console.log('‚ùå Conexi√≥n con backend perdida')
          onConnectionLost()
        }
      }
    }, 30000) // Verificar cada 30 segundos
  }

  /**
   * Detiene el health check
   */
  stopHealthCheck() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval)
      this.healthCheckInterval = null
    }
  }
}

// Instancia singleton
const backendDetector = new BackendDetector()

export default backendDetector
